L0:
{
  "compilerOptions": {
    "allowUnreachableCode": true,
    "allowUnusedLabels": true,
    "noStrictGenericChecks": true,
    "suppressExcessPropertyErrors": true,
    "suppressImplicitAnyIndexErrors": true,
    "disableSizeLimit": true,
    "maxNodeModuleJsDepth": 100,

    "noFallthroughCasesInSwitch": false,
    "noImplicitReturns": false,
    "noImplicitThis": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "alwaysStrict": false, // code runs with this anyway
    "strictNullChecks": false,
    "strictBindCallApply": false,
    "strictFunctionTypes": false,
    "strictPropertyInitialization": false,
    "noImplicitAny": false,
    "noImplicitThis": false,
    "useUnknownInCatchVariables": false,
    "exactOptionalPropertyTypes": false,
    "noImplicitOverride": false,
    "noPropertyAccessFromIndexSignature": false,
    "noUncheckedIndexedAccess": false,
    "noImplicitAny": false
  }
}



L???:
  // These should strip away some @ts-expect-error annotations????
  // which is incompatible with my approach.
  allowUnreachableCode: undefined (just editor/ide hints)
  allowUnusedLabels: undefined (just editor/ide hints)
  // maybe toggle these in CI?? If it fails in CI, that tells us authors+reviewers are missing stuff

  // maybe .js can be
    allowUnreachableCode: undefined (just editor/ide hints)
    allowUnusedLabels: undefined (just editor/ide hints)
  // .ts can be
    allowUnreachableCode: undefined (just editor/ide hints)
    allowUnusedLabels: undefined (just editor/ide hints)

L1:
{
  "compilerOptions": {
    "allowUnreachableCode": false, // assistive
    "allowUnusedLabels": false // assistive
  }
}

L1.2:
{
  "compilerOptions": {
    "noFallthroughCasesInSwitch": true, // assistive
    "noImplicitReturns": true // assistive
  }
}

L1.3
{
  "compilerOptions": {
    // likely developer mistakes, but no runtime errors...
    // Maybe these will just annoying on top of everything else?
    // maybe they are lower level simply because they are so easy to fix??
    // But they could unravel to a much larger problem?
    // maybe just not add a level to these?
    // or something like "L-a" "assistive" level?
    "noUnusedLocals": true
  }
}

L1.4
{
  "compilerOptions": {
    "noUnusedParameters": true, // assistive

    // Unwind "backwards-compat" flags
    // Likely programmer mistake:
    "suppressExcessPropertyErrors": false, // assistive

    "noStrictGenericChecks": false // restore strictGenericChecks
  }
}


L2.1?
{
  "compilerOptions": {
    // maybe call this "use strict" in the codebase :)
    "alwaysStrict": true // code runs with this anyway
  }
}



Strict mode:
{
  "compilerOptions": {
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,

    "useUnknownInCatchVariables": true,
    "strictNullChecks": true
  }
}



{
  "compilerOptions": {
    "exactOptionalPropertyTypes": true,

    // maybe even higher?
    "noPropertyAccessFromIndexSignature": true,
    "noUncheckedIndexedAccess": true,
  
    
    // higher yet:
    "noImplicitOverride": true,
    
    
    // highest level? or unique annotation?
    // These all get converted to explicit `any` so... no need for // @ts-expect-error...
    "noImplicitAny": true,
    "noImplicitThis": true,
    
    
    
    // Actually higher:
    // but, this can be auto-fixed with eslint, so idk:
    "importsNotUsedAsValues": error,
    
    // can this be auto-fixed??
    "forceConsistentCasingInFileNames": true,    
  }
}